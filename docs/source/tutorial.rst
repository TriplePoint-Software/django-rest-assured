Tutorial
========

Let's take a look at an
`example from the Django documentation <https://docs.djangoproject.com/en/dev/topics/db/queries/>`_
of a Weblog application:

.. code:: python

   from django.db import models


   class Blog(models.Model):
       name = models.CharField(max_length=100)
       tagline = models.TextField()

       def __str__(self):              # __unicode__ on Python 2
           return self.name


   class Author(models.Model):
       name = models.CharField(max_length=50)
       email = models.EmailField()

       def __str__(self):              # __unicode__ on Python 2
           return self.name


   class Entry(models.Model):
       blog = models.ForeignKey(Blog)
       headline = models.CharField(max_length=255)
       body_text = models.TextField()
       pub_date = models.DateField()
       mod_date = models.DateField()
       authors = models.ManyToManyField(Author)
       n_comments = models.IntegerField()
       n_pingbacks = models.IntegerField()
       rating = models.IntegerField()

       def __str__(self):              # __unicode__ on Python 2
           return self.headline

The above file will serve as the ``models.py`` file in this example application.

Say that we want to have a RESTful API endpoint for the ``Entry`` model.
We'll need a serializer for ``Entry`` objects, so this will serve as our ``serializers.py``:

.. code:: python

   from rest_framework import serializers
   from . import models


   class Entry(serializers.HyperlinkedModelSerializer):

       class Meta:
           model = models.Entry

Now we're ready to define our views. The following shall serve as ``views.py``:

.. code:: python

   from rest_framework import viewsets
   from . import models, serializers


   class Entries(viewsets.ModelViewSet):

       queryset = models.Entry.objects.all()
       serializer_class = serializers.Entry

And hooking that viewset with URL's, we'll add a ``urls.py`` and define a router:

.. code:: python

   from django.conf.urls import url, include
   from rest_framework import routers
   from . import views


   router = routers.DefaultRouter()
   router.register(r'entries', views.Entries)


   urlpatterns = [
       url(r'^', include(router.urls)),
   ]

And we'll assume the pattern above is added to the project's root ``urlpatterns``
under the prefix ``/api/``, so that our endpoint will look like ``/api/entries/``.

Now we have an API endpoint we can test. Yay!

To make things even easier we'll create a ``factories.py`` file
that will include factories for our models using `Factory Boy <http://factoryboy.readthedocs.org/>`_:

.. code:: python

   import datetime
   import factory
   from factory import fuzzy
   from . import models


   class Blog(factory.DjangoModelFactory):

       class Meta:
           model = models.Blog

       name = factory.Sequence(lambda n: 'Blog {0}'.format(n))
       tagline = factory.Sequence(lambda n: 'Blog {0} tag line'.format(n))


   class Author(factory.DjangoModelFactory):

       class Meta:
           model = models.Author

       name = factory.Sequence(lambda n: 'Author {0}'.format(n))
       email = factory.Sequence(lambda n: 'author{0}@example.com'.format(n))


   class Entry(factory.DjangoModelFactory):

       class Meta:
           model = models.Entry

       blog = factory.SubFactory(Blog)
       headline = factory.Sequence(lambda n: 'OMG Headline {0}!'.format(n))
       body_text = fuzzy.FuzzyText(length=100)
       pub_date = datetime.date(2014, 11, 12)
       mod_date = datetime.date(2014, 11, 12)
       rating = fuzzy.FuzzyInteger(low=1, high=5, step=1)
       n_pingbacks = 0
       n_comments = 0

       @factory.post_generation
       def authors(self, create, extracted, **kwargs):
           if not create:
               return

           if extracted:
               for author in extracted:
                   self.authors.add(author)

This will make testing fun.

Let's write the tests! This shall be our ``tests.py`` file:

.. code:: python

   from rest_assured.testcases import ReadWriteRESTAPITestCaseMixin, BaseRESTAPITestCase
   from . import factories


   class EntryAPITestCase(ReadWriteRESTAPITestCaseMixin, BaseRESTAPITestCase):

       base_name = 'entry' # this is the base_name generated by the DefaultRouter
       factory_class = factories.Entry
       update_data = {'rating': 5}

       def setUp(self):
          self.author = factories.Author.create()
          super(EntryAPITestCase, self).setUp()

       def get_object(self, factory):
           return factory.create(authors=[self.author])

       def get_create_data(self):
          return {'headline': 'Lucifer Sam',
                  'body_text': 'is a song by British psychedelic rock band Pink Floyd.',
                  'authors': [self.author.pk]}

And that's it!

This simple class will make 5 tests if we'll run:

.. code:: sh

   $ python manage.py test

And will produce an output like such:

.. code:: sh

   user@machine:~/project$ python manage.py test
   Creating test database for alias 'default'...
   .....
   ----------------------------------------------------------------------
   Ran 5 tests in 0.155s

   OK
   Destroying test database for alias 'default'...

You can see the above example is not entirely trivial.
We had to do some setup work to ensure we have a ready made Author instance.
We also created dynamic getters for the main test object and the data dict used for
the create request. In both cases this was required to obtain a lazy reference
to the Author instance we created in ``setUp()``.

Say now our API is not public and requires token authentication. We'll need a user
factory to mock successful requests. Let's create that factory:

.. code:: python

   from django.contrib import auth


   class User(factory.DjangoModelFactory):

       class Meta:

           model = auth.get_user_model()
           exclude = ('raw_password',)

       first_name = 'Robert'
       last_name = factory.Sequence(lambda n: 'Paulson the {0}'.format(n))
       email = factory.sequence(lambda n: 'account{0}@example.com'.format(n))
       username = 'mayhem'
       # this is required:
       raw_password = '123'
       password = factory.PostGenerationMethodCall('set_password', raw_password)
       is_active = True

We'll need to tweak some settings:

.. code:: python

   REST_FRAMEWORK = {
       'DEFAULT_AUTHENTICATION_CLASSES': (
           'rest_framework.authentication.TokenAuthentication',
       ),
       'DEFAULT_PERMISSION_CLASSES': (
           'rest_framework.permissions.IsAuthenticated',
       )
   }

   ...

   INSTALLED_APPS = (
       ...
       'rest_framework.authtoken'
   )

Running our tests now will fail, since all responses will return with a 401 status. Which is great.

Let's also assume we followed the example in Django REST Framework's docs and created a signal
receiver that creates a Token instance for every newly created user.

For simplicity, also, let's assume that that ``User`` factory resides in the previous ``factories.py``
module.

We'll need to add 2 more attributes to our test case:

.. code:: python

   ...
   user_factory = factories.User
   use_token_auth = True
   ...

Then our ``tests.py`` now needs to be:

.. code:: python

   from rest_assured.testcases import ReadWriteRESTAPITestCaseMixin, BaseRESTAPITestCase
   from . import factories


   class EntryAPITestCase(ReadWriteRESTAPITestCaseMixin, BaseRESTAPITestCase):

       base_name = 'entry' # this is the base_name generated by the DefaultRouter
       factory_class = factories.Entry
       user_factory = factories.User
       use_token_auth = True
       update_data = {'rating': 5}

       def setUp(self):
          self.author = factories.Author.create()
          super(EntryAPITestCase, self).setUp()

       def get_object(self, factory):
           return factory.create(authors=[self.author])

       def get_create_data(self):
          return {'headline': 'Lucifer Sam',
                  'body_text': 'is a song by British psychedelic rock band Pink Floyd.',
                  'authors': [self.author.pk]}

And our tests pass again.
